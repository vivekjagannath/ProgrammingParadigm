<html>

<head>
    <title>Programming Paradigm</title>
    <link rel="stylesheet" href="style.css" />
    <link href="https://fonts.googleapis.com/css2?family=Bangers&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Indie+Flower&display=swap" rel="stylesheet">
</head>

<body>
    <div class="static">
        <h1>List of contents</h1>
        <ul>
            <li><a href="#intro"><button>Introduction</button></a></li>
            <li><a href="#Structural"><button>Structural</button></a></li>
            <li><a href="#Procedural"><button>Procedural</button></a></li>
            <li><a href="#Object"><button>Object oriented</button></a></li>
            <li><a href="#Event"><button>Event driven</button></a></li>
            <li><a href="#Declarative"><button>Declarative</button></a></li>
            <li><a href="#Imperative"><button>Imperative</button></a></li>
            <li><a href="#Parallel"><button>Parallel</button></a></li>
            <li><a href="#Concurrent"><button>Concurrent</button></a></li>
            <li><a href="#Functional"><button>Functional</button></a></li>
            <li><a href="#Logic"><button>Logic</button></a></li>
            <li><a href="#Dependent"><button>Dependent</button></a></li>
            <li><a href="#Network"><button>Network</button></a></li>
            <li><a href="#Symbolic"><button>Symbolic</button></a></li>
            <li><a href="#Automata"><button>Automata</button></a></li>
            <li><a href="#GUI"><button>GUI</button></a></li>
        </ul>
    </div>
    <div class="dyn">
        <div class="first" id="intro">
            <h2>Introduction to paradigms</h2>
        </div>
        <div class="second" id="Structural">
            <h2>Structural paradigm</h2>
            <br>
            <div class = "struc_cont">
            <p><center><b>Program is made as a single structure. Code will execute the instruction by instruction one after the other. It doesn’t support the possibility of jumping from one instruction to some other with the help of any statement like GOTO,etc. The structured program consists of well structured and separated modules. But the entry and exit in a Structured program is a single-time event. It means that the program uses single-entry and single-exit elements. Instructions in this approach will be executed in a serial and structured manner. The languages that support Structured programming approach are: C, C++, Java, C# ..etc The structured program mainly consists of three types of elements, viz. , Selection , Sequence, and Iteration statements.</b></center></p>
            </div>
            <div class = "struc_code">
            <figure>
                <pre>
                    <code class = "Language: Python" contenteditable spellcheck="false">
num1 = 23
num2 = 15

big = num1 if num1 > num2 else num2

print("The greater number is ", big)

                    </code>
                </pre>
            </figure>            
        </div>
        </div>
        <div class="third" id="Procedural">
            <h2>Procedural paradigm</h2>
            <br>
            <div class = "struc_cont">
            <p><center><b>High level languages such as COBOL, FORTRAN and C, is commonly known as procedure oriented programming(POP). In the procedure oriented programming, program is divided into sub programs or modules and then assembled to form a complete program. These modules are called functions. The problem is viewed as a sequence of things to be done. The primary focus is on functions. Procedure-oriented programming basically consists of writing a list of instructions for the computer to follow and organizing these instructions into groups known as functions.</b></center></p>
            </div>
            <div class = "struc_code">
            <figure>
                <pre>
                    <code class = "Language: Python" contenteditable spellcheck="false">
sum = 0

for i in range(12):
    sum = sum + 1

print(sum)

                    </code>
                </pre>
            </figure>            
        </div>
        </div>
        <div class="fourth" id="Object">
            <h2>Object oriented paradigm</h2>
            <br>
            <div class = "struc_cont">
            <p><center><b>OOP treat data as a critical element in the program development and does not allow it to flow freely around the system. It ties data more closely to the functions that operate on it, and protects it from accidental modification from outside.functions. OOP allows decomposition of a problem into a number of entities called objects and then build data functions around these objects. The data of an object can be accessed only by the functions associated with that object. Functions of one object can access the functions of another objects.</b></center></p>
            </div>
            <div class = "struc_code">
            <figure>
                <pre>
                    <code class = "Language: Python" contenteditable spellcheck="false">
class Parrot:
    species = "bird"

    def __init__(self, name, age):
        self.name = name
        self.age = age

blu = Parrot("Blu", 10)
woo = Parrot("Woo", 15)                

print(blu.name)

                    </code>
                </pre>
            </figure>            
        </div>
        </div>
        <div class="fifth" id="Event">
            <h2>Event driven paradigm</h2>
            <br>
            <div class = "struc_cont">
            <p><center><b>Event-driven programming is a programming paradigm in which the flow of program execution is determined by events - for example a user action such as a mouse click, key press, or a message from the operating system or another program. An event-driven application is designed to detect events as they occur, and then deal with them using an appropriate event-handling procedure. In a typical modern event-driven program, there is no discernible flow of control. The main routine is an event-loop that waits for an event to occur, and then invokes the appropriate event-handling routine. Event callback is a function that is invoked when something significant happens like when click event is performed by user or the result of database query is available.</b></center></p>
            </div>
            <div class = "struc_code">
            <figure>
                <pre>
                    <code class = "Language: Python" contenteditable spellcheck="false">
def hello():
    msg = messagebox.showinfo("GUI Event Demo", t.get())
root = tk.Tk()
root.geometry("200x200")
l1 = tk.Label(root, text="Name:")
l1.grid(row = 0)
t = tk.Entry(root)
t.grid(row=0, column=1)
b = tk.Button(root, text='FireMe', commmand=hello)
b.grid(row=1, columnspan=2);
root.mainloop()

                    </code>
                </pre>
            </figure>            
        </div>
        </div>
        <div class="sixth" id="Declarative">
            <h2>Declarative paradigm</h2>
            <br>
            <div class = "struc_cont">
            <p><center><b>Declarative programming is a programming paradigm that expresses the logic of a computation without describing its control flow. This paradigm often considers programs as theories of a formal logic, and computations as deductions in that logic space. Declarative programming is often defined as any style of programming that is not imperative. Common declarative languages include those of database query languages (SQL), logic programming, functional programming, etc. A program that describes what computation should be performed and not how to compute it. Non-imperative, non-procedural. Any programming language that lacks side effects(example: a function might modify a global variable or static variable, modify one of its arguments, raise an exception,). A language with a clear correspondence to mathematical logic.</b></center></p>
            </div>
            <div class = "struc_code">
            <figure>
                <pre>
                    <code class = "Language: Python" contenteditable spellcheck="false">
SELECT column_name,
    CASE
        WHEN condition THEN 'Result_1'
        WHEN condition THEN 'Result_2'
        ELSE 'Result_3'
    END
FROM table_name;

                    </code>
                </pre>
            </figure>            
        </div>
        </div>
        <div class="seventh" id="Imperative">
            <h2>Imperative paradigm</h2>
            <br>
            <div class = "struc_cont">
            <p><center><b>It’s a programming paradigm that describes computation as statements that change a program state. Computations are performed through a guided sequence of steps, in which these variables are referred to or changed. The order of the steps is crucial, because a given step will have different consequences depending on the current values of variables when the step is executed. Imperative programs define sequences of commands/statements for the computer that change a program state (i.e., set of variables)</b></center></p>
            </div>
            <div class = "struc_code">
            <figure>
                <pre>
                    <code class = "Language: Python" contenteditable spellcheck="false">
sum = 0
sum = sum + 1
sum = sum + 2
sum = sum + 3
sum = sum + 4
sum = sum + 5

print(sum)

                    </code>
                </pre>
            </figure>            
        </div>
        </div>
        <div class="eighth" id="Parallel">
            <h2>Parallel paradigm</h2>
            <br>
            <div class = "struc_cont">
            <p><center><b>A system is said to be parallel if it can support two or more actions executing simultaneously i.e., multiple actions aresimultaneously executed in parallel systems. Explicit Parallelism is characterized by the presence of explicit constructs in the programming language, aimed at describing (to a certain degree of detail) the way in which the parallel computation will take place. Whereas Implicit Parallelism allows programmers to write their programs without any concern about the exploitation of parallelism.</b></center></p>
            </div>
            <div class = "struc_code">
            <figure>
                <pre>
                    <code class = "Language: Python" contenteditable spellcheck="false">
import multiprocessing
def worker(num):
    print('Worker: ', num)
    for i in range(num):
        print(i)
    return

jobs = []
for i in range(1,5):
    p = multiprocessing.Proccess(target = worker, args = (i+10,))
    jobs.append(p)
    p.start()

                    </code>
                </pre>
            </figure>            
        </div>
        </div>
        <div class="ninth" id="Concurrent">
            <h2>Concurrent paradigm</h2>
            <br>
            <div class = "struc_cont">
            <p><center><b>Computing systems model the world, and the world contains actors that execute independently of, but communicate with each other. In modelling the world, many (possibly) parallel executions have to be composed and coordinated, and that's where the study of concurrency comes in. In the shared memory model of concurrency, concurrent modules interact by reading and writing shared objects in memory. In the message-passing model, concurrent modules interact by sending messages to each other through a communication channel. Modules send off messages, and incoming messages to each module are queued up for handling.</b></center></p>
            </div>
            <div class = "struc_code">
            <figure>
                <pre>
                    <code class = "Language: Python" contenteditable spellcheck="false">
import threading
x = 0
COUNT = 100

def incr():
    global x
    for i in range(COUNT):
        x = x + 1
        print(x)

t1 = threading.Thread(target=incr)
t2 = threading.Thread(target=decr)
t1.start()
t2.start()
t1.join()
t2.join()
print(x)

                    </code>
                </pre>
            </figure>            
        </div>
        </div>
        <div class="tenth" id="Functional">
            <h2>Functional paradigm</h2>
            <br>
            <div class = "struc_cont">
            <p><center><b>Functional programming is a programming paradigm in which it is tried to bind each and everything in pure mathematical functions. It is a declarative type of programming style that focuses on what to solve rather than how to solve. Functional programming paradigm is based on lambda calculus. Instead of statements, functional programming makes use of expressions. Unlike a statement, which is executed to assign variables, evaluation of an expression produces a value.Functional programming is a declarative paradigm because it relies on expressions and declarations rather than statements.Unlike procedures that depend on a local or global state, value outputs in FP depend only on the arguments passed to thefunction. Functional programming consists only of PURE functions. In functional programming, control flow is expressed by combining function calls, rather than by assigning values to variables.</b></center></p>
            </div>
            <div class = "struc_code">
            <figure>
                <pre>
                    <code class = "Language: Python" contenteditable spellcheck="false">
def isPrime(number):
    for i in range(2, math.floor(sqrt(number))):
        if number % i == 0:
            return False
    return True

ifPrime(15)

                    </code>
                </pre>
            </figure>            
        </div>
        </div>
        <div class="eleventh" id="Logic">
            <h2>Logic paradigm</h2>
            <br>
            <div class = "struc_cont">
            <p><center><b>It can be an abstract model of computation. Solve logical problems like puzzles, series . Have knowledge base which we know before and along with the question you specify knowledge and how that knowledge is to be applied through a series of rules. The Logical Paradigm takes a declarative approach to problem-solving. Various logical assertions about a situation are made, establishing all known facts. Then queries are made.</b></center></p>
            </div>
            <div class = "struc_code">
            <figure>
                <pre>
                    <code class = "Language: Python" contenteditable spellcheck="false">
father(John, Bill)
father(John, Lisa)
mother(Mary, Bill)
mother(Mary, Lisa)

?- mother(X, Bill)
X = Mary

                    </code>
                </pre>
            </figure>            
        </div>
        </div>
        <div class="twelfth" id="Dependent">
            <h2>Dependent paradigm</h2>
            <br>
            <div class = "struc_cont">
            <p><center><b>Writing a correct computer program is hard and proving that a program is correct is even harder. Dependent Types allow us to write programs and know they are correct before running them.<br>
                Dependent types: you can specify types that can check the value of your variables at compile time. A function has dependent type if the type of a function's result depends on the VALUE of its argument; this is not the same thing as a ParameterizedType. The second order lambda calculus possesses functions with dependent types.</b></center></p>
            </div>
            <div class = "struc_code">
            <figure>
                <pre>
                    <code class = "Language: Python" contenteditable spellcheck="false">
from dependent import Integer, TenOrMore, LessThanTen
a = Integer(5)
print(a.value, type(a))

a.add(10)
print(a.value, type(a))

                    </code>
                </pre>
            </figure>            
        </div>
        </div>
        <div class="thirteenth" id="Network">
            <h2>Network paradigm</h2>
            <br>
            <div class = "struc_cont">
            <p><center><b>The Network paradigm involves thinking of computing in terms of a client, who is essentially in need of some type of information, and a server, who has lots of information and is just waiting to hand it out. Typically, a client will connect to a server and query for certain information. The server will go off and find the information and then return it to the client. Network programming uses a particular type of network communication known as sockets. A socket is a software abstraction for an input or output medium of communication.</b></center></p>
            </div>
            <div class = "struc_code">
            <figure>
                <pre>
                    <code class = "Language: Python" contenteditable spellcheck="false">
import socket

s = socket.socket()
host = socket.gethostname()
port = 12345

s.connect((host, port))
print s.recv(1024)
s.close()    

                    </code>
                </pre>
            </figure>            
        </div>
        </div>
        <div class="fourteenth" id="Symbolic">
            <h2>Symbolic paradigm</h2>
            <br>
            <div class = "struc_cont">
            <p><center><b>Symbolic computation deals with the computation of mathematical objects symbolically. This means that the mathematical objects are represented exactly, not approximately, and mathematical expressions with unevaluated variables are left in symbolic form.</b></center></p>
            </div>
            <div class = "struc_code">
            <figure>
                <pre>
                    <code class = "Language: Python" contenteditable spellcheck="false">
sym.expand((x+y)*3)

Answer is x3 + 3*x2*y + 3*x*y2 + y*3

                    </code>
                </pre>
            </figure>            
        </div>
        </div>
        <div class="fifteenth" id="Automata">
            <h2>Automata paradigm</h2>
            <br>
            <div class = "struc_cont">
            <p><center><b>Automata-based programming is a programming paradigm in which the program or its part is thought of as a model of a finite state machine or any other formal automation. Automata theory is the study of abstract computational devices.Abstract devices are (simplified) models of real computations. Computations happen everywhere: On your laptop, on your cell phone, in nature, etc.</b></center></p>
            </div>
            <div class = "struc_code">
            <figure>
                <pre>
                    <code class = "Language: Python" contenteditable spellcheck="false">
import automatabpp as FSM

FSM.BEHAVIOUR.load_behaviour_from_graph("first.graphml", "My First Finite State Machine")

@FSM.EXECUTION.state
def ON_START(*args, **kwargs):
    print("FSM start")

@FSM.EXECUTION.state
def HELLO(*args, **kwargs):
    print("Hello!")

FSM.OPERATION.start()
FSM.OPERATION.run("is_anyone_there")

                    </code>
                </pre>
            </figure>            
        </div>
        </div>
        <div class="sixteenth" id="GUI">
            <h2>GUI paradigm</h2>
            <br>
            <div class = "struc_cont">
            <p><center><b>A major task that a GUI designer needs to do is to determine what will happen when a GUI is invoked. Every GUI component may generate different kinds of “events” when a user makes access to it using his mouse or keyboard. E.g. if a user moves his mouse on top of a button, an event of that button will be generated to the Windows system. E.g. if the user further clicks, then another event of that button will be generated (actually it is the click event). For any event generated, the system will first check if there is an event handler, which defines the action for that event. For a GUI designer, he needs to develop the event handler to determine the action that he wants Windows to take for that event.</b></center></p>
            </div>
            <div class = "struc_code">
            <figure>
                <pre>
                    <code class = "Language: Python" contenteditable spellcheck="false">
import Tkinter
top = Tkinter.Tk()

# Code to add widgets will go here...

top.mainloop()

                    </code>
                </pre>
            </figure>            
        </div>
        </div>
    </div>

</body>

</html>